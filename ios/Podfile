require File.join(File.dirname(`node --print "require.resolve('expo/package.json')"`), "scripts/autolinking")
require File.join(File.dirname(`node --print "require.resolve('react-native/package.json')"`), "scripts/react_native_pods")

require 'json'
podfile_properties = JSON.parse(File.read(File.join(__dir__, 'Podfile.properties.json'))) rescue {}

def ccache_enabled?(podfile_properties)
  # Environment variable takes precedence
  return ENV['USE_CCACHE'] == '1' if ENV['USE_CCACHE']
  
  # Fall back to Podfile properties
  podfile_properties['apple.ccacheEnabled'] == 'true'
end

ENV['RCT_NEW_ARCH_ENABLED'] ||= '0' if podfile_properties['newArchEnabled'] == 'false'
ENV['EX_DEV_CLIENT_NETWORK_INSPECTOR'] ||= podfile_properties['EX_DEV_CLIENT_NETWORK_INSPECTOR']
ENV['RCT_USE_RN_DEP'] ||= '1' if podfile_properties['ios.buildReactNativeFromSource'] != 'true' && podfile_properties['newArchEnabled'] != 'false'
ENV['RCT_USE_PREBUILT_RNCORE'] ||= '1' if podfile_properties['ios.buildReactNativeFromSource'] != 'true' && podfile_properties['newArchEnabled'] != 'false'
platform :ios, podfile_properties['ios.deploymentTarget'] || '15.1'

# Explicitly specify the Xcode project
project 'otlfitnessapp.xcodeproj'

prepare_react_native_project!

target 'otlfitnessapp' do
  use_expo_modules!

  if ENV['EXPO_USE_COMMUNITY_AUTOLINKING'] == '1'
    config_command = ['node', '-e', "process.argv=['', '', 'config'];require('@react-native-community/cli').run()"];
  else
    config_command = [
      'node',
      '--no-warnings',
      '--eval',
      'require(\'expo/bin/autolinking\')',
      'expo-modules-autolinking',
      'react-native-config',
      '--json',
      '--platform',
      'ios'
    ]
  end

  config = use_native_modules!(config_command)

  use_frameworks! :linkage => podfile_properties['ios.useFrameworks'].to_sym if podfile_properties['ios.useFrameworks']
  use_frameworks! :linkage => ENV['USE_FRAMEWORKS'].to_sym if ENV['USE_FRAMEWORKS']

  use_react_native!(
    :path => config[:reactNativePath],
    :hermes_enabled => podfile_properties['expo.jsEngine'] == nil || podfile_properties['expo.jsEngine'] == 'hermes',
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/..",
    :privacy_file_aggregation_enabled => podfile_properties['apple.privacyManifestAggregationEnabled'] != 'false',
  )

  post_install do |installer|
    react_native_post_install(
      installer,
      config[:reactNativePath],
      :mac_catalyst_enabled => false,
      :ccache_enabled => ccache_enabled?(podfile_properties),
    )

    # Fix minimum iOS deployment target for all pods and suppress nullability warnings
    installer.pods_project.targets.each do |target|
      target.build_configurations.each do |config|
        config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '15.1'
        # Suppress nullability/pointer warnings from third-party Expo modules
        config.build_settings['GCC_WARN_ABOUT_POINTER_SIGNEDNESS'] = 'NO'
        config.build_settings['CLANG_WARN_NULLABLE_TO_NONNULL_CONVERSION'] = 'NO'
        config.build_settings['CLANG_ANALYZER_NONNULL'] = 'NO'
      end
    end

    # Replace resources script with sandbox-compatible version
    script_path = "Pods/Target Support Files/Pods-otlfitnessapp/Pods-otlfitnessapp-resources.sh"
    if File.exist?(script_path)
      # Completely rewrite the script (same approach as ci_pre_xcodebuild.sh)
      script = <<~'SCRIPT'
        #!/bin/sh
        set -e
        set -u
        set -o pipefail

        install_resource() {
          case $1 in
            *.storyboard|*.xib|*.xcdatamodel|*.xcmappingmodel|*.xcassets)
              echo "Skipping special resource: $1"
              ;;
            *)
              if [ -e "$1" ]; then
                echo "cp: Installing $(basename "$1")"
                mkdir -p "${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}"
                cp -LR "$1" "${TARGET_BUILD_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}/"
              fi
              ;;
          esac
        }

        install_resource "${PODS_CONFIGURATION_BUILD_DIR}/EXConstants/EXConstants.bundle"
        install_resource "${PODS_CONFIGURATION_BUILD_DIR}/EXConstants/ExpoConstants_privacy.bundle"
        install_resource "${PODS_CONFIGURATION_BUILD_DIR}/ExpoFileSystem/ExpoFileSystem_privacy.bundle"
        install_resource "${PODS_CONFIGURATION_BUILD_DIR}/RCT-Folly/RCT-Folly_privacy.bundle"
        install_resource "${PODS_CONFIGURATION_BUILD_DIR}/RNCAsyncStorage/RNCAsyncStorage_resources.bundle"
        install_resource "${PODS_CONFIGURATION_BUILD_DIR}/React-Core/React-Core_privacy.bundle"
        install_resource "${PODS_CONFIGURATION_BUILD_DIR}/React-cxxreact/React-cxxreact_privacy.bundle"
        install_resource "${PODS_CONFIGURATION_BUILD_DIR}/boost/boost_privacy.bundle"
        install_resource "${PODS_CONFIGURATION_BUILD_DIR}/glog/glog_privacy.bundle"

        echo "=== Resources copied successfully ==="
      SCRIPT
      File.write(script_path, script)
      File.chmod(0755, script_path)
      puts "[Podfile] Replaced resources script with sandbox-compatible version"
    end

    # Replace frameworks script with sandbox-compatible version using ditto
    frameworks_script_path = "Pods/Target Support Files/Pods-otlfitnessapp/Pods-otlfitnessapp-frameworks.sh"
    if File.exist?(frameworks_script_path)
      # Completely rewrite the script (same approach as ci_pre_xcodebuild.sh)
      script = <<~'SCRIPT'
        #!/bin/sh
        set -e
        set -u
        set -o pipefail

        # Sandbox-compatible frameworks embedding (uses ditto instead of rsync)

        if [ -z ${FRAMEWORKS_FOLDER_PATH+x} ]; then
          exit 0
        fi

        echo "mkdir -p ${CONFIGURATION_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}"
        mkdir -p "${CONFIGURATION_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}"

        COCOAPODS_PARALLEL_CODE_SIGN="${COCOAPODS_PARALLEL_CODE_SIGN:-false}"
        SWIFT_STDLIB_PATH="${TOOLCHAIN_DIR}/usr/lib/swift/${PLATFORM_NAME}"

        install_framework()
        {
          if [ -r "${BUILT_PRODUCTS_DIR}/$1" ]; then
            local source="${BUILT_PRODUCTS_DIR}/$1"
          elif [ -r "${BUILT_PRODUCTS_DIR}/$(basename "$1")" ]; then
            local source="${BUILT_PRODUCTS_DIR}/$(basename "$1")"
          elif [ -r "$1" ]; then
            local source="$1"
          fi

          local destination="${TARGET_BUILD_DIR}/${FRAMEWORKS_FOLDER_PATH}"
          local framework_name="$(basename "$source")"

          if [ -L "${source}" ]; then
            echo "Symlinked..."
            source="$(readlink "${source}")"
          fi

          echo "ditto: Installing ${framework_name} to ${destination}"

          # Use ditto instead of rsync - it's sandbox-friendly
          ditto --noextattr --norsrc "${source}" "${destination}/${framework_name}"

          # Remove unnecessary directories
          rm -rf "${destination}/${framework_name}/Headers" 2>/dev/null || true
          rm -rf "${destination}/${framework_name}/PrivateHeaders" 2>/dev/null || true
          rm -rf "${destination}/${framework_name}/Modules" 2>/dev/null || true

          local basename
          basename="$(basename -s .framework "$1")"
          binary="${destination}/${basename}.framework/${basename}"

          if ! [ -r "$binary" ]; then
            binary="${destination}/${basename}"
          elif [ -L "${binary}" ]; then
            echo "Destination binary is symlinked..."
            dirname="$(dirname "${binary}")"
            binary="${dirname}/$(readlink "${binary}")"
          fi

          # Strip invalid architectures
          if [[ "$(file "$binary")" == *"dynamically linked shared library"* ]]; then
            strip_invalid_archs "$binary"
          fi

          # Code sign
          code_sign_if_enabled "${destination}/$(basename "$1")"
        }

        STRIP_BINARY_RETVAL=0

        strip_invalid_archs() {
          binary="$1"
          warn_missing_arch=${2:-true}
          binary_archs="$(lipo -info "$binary" | rev | cut -d ':' -f1 | awk '{$1=$1;print}' | rev)"
          intersected_archs="$(echo ${ARCHS[@]} ${binary_archs[@]} | tr ' ' '\n' | sort | uniq -d)"
          if [[ -z "$intersected_archs" ]]; then
            if [[ "$warn_missing_arch" == "true" ]]; then
              echo "warning: [CP] Vendored binary '$binary' contains architectures ($binary_archs) none of which match the current build architectures ($ARCHS)."
            fi
            STRIP_BINARY_RETVAL=1
            return
          fi
          stripped=""
          for arch in $binary_archs; do
            if ! [[ "${ARCHS}" == *"$arch"* ]]; then
              lipo -remove "$arch" -output "$binary" "$binary"
              stripped="$stripped $arch"
            fi
          done
          if [[ "$stripped" ]]; then
            echo "Stripped $binary of architectures:$stripped"
          fi
          STRIP_BINARY_RETVAL=0
        }

        code_sign_if_enabled() {
          if [ -n "${EXPANDED_CODE_SIGN_IDENTITY:-}" -a "${CODE_SIGNING_REQUIRED:-}" != "NO" -a "${CODE_SIGNING_ALLOWED}" != "NO" ]; then
            echo "Code Signing $1 with Identity ${EXPANDED_CODE_SIGN_IDENTITY_NAME}"
            local code_sign_cmd="/usr/bin/codesign --force --sign ${EXPANDED_CODE_SIGN_IDENTITY} ${OTHER_CODE_SIGN_FLAGS:-} --preserve-metadata=identifier,entitlements '$1'"
            if [ "${COCOAPODS_PARALLEL_CODE_SIGN}" == "true" ]; then
              code_sign_cmd="$code_sign_cmd &"
            fi
            echo "$code_sign_cmd"
            eval "$code_sign_cmd"
          fi
        }

        if [[ "$CONFIGURATION" == "Debug" ]]; then
          install_framework "${PODS_XCFRAMEWORKS_BUILD_DIR}/hermes-engine/Pre-built/hermes.framework"
        fi
        if [[ "$CONFIGURATION" == "Release" ]]; then
          install_framework "${PODS_XCFRAMEWORKS_BUILD_DIR}/hermes-engine/Pre-built/hermes.framework"
        fi
        if [ "${COCOAPODS_PARALLEL_CODE_SIGN}" == "true" ]; then
          wait
        fi

        echo "=== Frameworks embedded successfully ==="
      SCRIPT
      File.write(frameworks_script_path, script)
      File.chmod(0755, frameworks_script_path)
      puts "[Podfile] Replaced frameworks script with ditto-based version for sandbox compatibility"
    end
  end
end
